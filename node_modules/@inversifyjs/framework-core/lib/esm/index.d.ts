import { Newable, BindingScope, ServiceIdentifier } from 'inversify';

declare function getCatchErrorMetadata(target: Function): Set<Newable<Error> | null>;

interface ErrorFilter<TError = unknown, TRequest = any, TResponse = any, TResult = any> {
    catch(error: TError, request: TRequest, response: TResponse): Promise<TResult> | TResult;
}

declare function getClassErrorFilterMetadata(classConstructor: NewableFunction): Set<Newable<ErrorFilter>>;

declare function getClassMethodErrorFilterMetadata(classConstructor: NewableFunction, methodKey: string | symbol): Set<Newable<ErrorFilter>>;

interface CatchErrorOptions {
    error?: Newable<Error>;
    scope?: BindingScope;
}

declare function CatchError(errorOrCatchErrorOptions?: Newable<Error> | CatchErrorOptions): ClassDecorator;

declare function UseErrorFilter(...interceptorList: Newable<ErrorFilter>[]): ClassDecorator & MethodDecorator;

interface Guard<TRequest = any> {
    activate(request: TRequest): Promise<boolean> | boolean;
}

declare function getClassGuardList<TRequest = any>(classConstructor: NewableFunction): ServiceIdentifier<Guard<TRequest>>[];

declare function getClassMethodGuardList<TRequest = any>(classConstructor: NewableFunction, methodKey: string | symbol): ServiceIdentifier<Guard<TRequest>>[];

declare function UseGuard(...guardList: ServiceIdentifier<Guard>[]): ClassDecorator & MethodDecorator;

interface InterceptorTransformObject {
    push: (transform: (value: unknown) => unknown) => void;
}

interface Interceptor<TRequest = any, TResponse = any> {
    intercept(request: TRequest, response: TResponse, next: () => Promise<InterceptorTransformObject>): Promise<void>;
}

declare function getClassInterceptorList(classConstructor: NewableFunction): ServiceIdentifier<Interceptor>[];

declare function getClassMethodInterceptorList(classConstructor: NewableFunction, methodKey: string | symbol): ServiceIdentifier<Interceptor>[];

declare function UseInterceptor(...interceptorList: ServiceIdentifier<Interceptor>[]): ClassDecorator & MethodDecorator;

interface Middleware<TRequest = any, TResponse = any, TNextFunction = any, TResult = any> {
    execute(request: TRequest, response: TResponse, next: TNextFunction): Promise<TResult> | TResult;
}

declare enum MiddlewarePhase {
    PreHandler = "preHandler",
    PostHandler = "postHandler"
}

interface ApplyMiddlewareOptions {
    phase: MiddlewarePhase;
    middleware: ServiceIdentifier<Middleware> | ServiceIdentifier<Middleware>[];
}

interface MiddlewareOptions {
    postHandlerMiddlewareList: ServiceIdentifier<Middleware>[];
    preHandlerMiddlewareList: ServiceIdentifier<Middleware>[];
}

declare function buildMiddlewareOptionsFromApplyMiddlewareOptions(applyMiddlewareOptionsList: (ServiceIdentifier<Middleware> | ApplyMiddlewareOptions)[]): MiddlewareOptions;

declare function getClassMethodMiddlewareList(classConstructor: NewableFunction, methodKey: string | symbol): (ServiceIdentifier<Middleware> | ApplyMiddlewareOptions)[];

declare function getClassMiddlewareList(classConstructor: NewableFunction): (ServiceIdentifier<Middleware> | ApplyMiddlewareOptions)[];

declare function ApplyMiddleware(...middlewareList: (ServiceIdentifier<Middleware> | ApplyMiddlewareOptions)[]): ClassDecorator & MethodDecorator;

interface PipeMetadata {
    targetClass: NewableFunction;
    methodName: string | symbol;
    parameterIndex: number;
}

interface Pipe<TInput = unknown, TOutput = unknown> {
    execute(input: TInput, metadata: PipeMetadata): Promise<TOutput> | TOutput;
}

declare function isPipe(value: unknown): value is Pipe;

export { ApplyMiddleware, CatchError, MiddlewarePhase, UseErrorFilter, UseGuard, UseInterceptor, buildMiddlewareOptionsFromApplyMiddlewareOptions, getCatchErrorMetadata, getClassErrorFilterMetadata, getClassGuardList, getClassInterceptorList, getClassMethodErrorFilterMetadata, getClassMethodGuardList, getClassMethodInterceptorList, getClassMethodMiddlewareList, getClassMiddlewareList, isPipe };
export type { ApplyMiddlewareOptions, CatchErrorOptions, ErrorFilter, Guard, Interceptor, InterceptorTransformObject, Middleware, MiddlewareOptions, Pipe, PipeMetadata };
