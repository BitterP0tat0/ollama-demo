"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InversifyHttpAdapter = void 0;
const node_stream_1 = require("node:stream");
const framework_core_1 = require("@inversifyjs/framework-core");
const logger_1 = require("@inversifyjs/logger");
const InversifyHttpAdapterError_1 = require("../../error/models/InversifyHttpAdapterError");
const InversifyHttpAdapterErrorKind_1 = require("../../error/models/InversifyHttpAdapterErrorKind");
const isHttpResponse_1 = require("../../httpResponse/calculations/isHttpResponse");
const ErrorHttpResponse_1 = require("../../httpResponse/models/ErrorHttpResponse");
const ForbiddenHttpResponse_1 = require("../../httpResponse/models/ForbiddenHttpResponse");
const InternalServerErrorHttpResponse_1 = require("../../httpResponse/models/InternalServerErrorHttpResponse");
const buildRouterExplorerControllerMetadataList_1 = require("../../routerExplorer/calculations/buildRouterExplorerControllerMetadataList");
const setErrorFilterToErrorFilterMap_1 = require("../actions/setErrorFilterToErrorFilterMap");
const areAllParamsSync_1 = require("../calculations/areAllParamsSync");
const buildHttpResponseErrorFilter_1 = require("../calculations/buildHttpResponseErrorFilter");
const buildInterceptedHandler_1 = require("../calculations/buildInterceptedHandler");
const buildSyncCallRouteHandler_1 = require("../calculations/buildSyncCallRouteHandler");
const getErrorFilterForError_1 = require("../calculations/getErrorFilterForError");
const httpApplicationServiceIdentifier_1 = require("../models/httpApplicationServiceIdentifier");
const RequestMethodParameterType_1 = require("../models/RequestMethodParameterType");
const DEFAULT_ERROR_MESSAGE = 'An unexpected error occurred';
class InversifyHttpAdapter {
    httpAdapterOptions;
    _app;
    _logger;
    #awaitableRequestMethodParamTypes;
    #container;
    #customNativeParameterDecoratorHandlerOptions;
    #customParameterDecoratorHandlerOptions;
    #errorTypeToGlobalErrorFilterMap;
    #globalGuardList;
    #globalInterceptorList;
    #globalPipeList;
    #postHandlerMiddlewareList;
    #preHandlerMiddlewareList;
    #isBuilt;
    constructor(container, defaultHttpAdapterOptions, httpAdapterOptions, awaitableRequestMethodParamTypes, customApp) {
        this.#awaitableRequestMethodParamTypes = new Set(awaitableRequestMethodParamTypes);
        this.#container = container;
        this.#customParameterDecoratorHandlerOptions =
            this.#buildCustomParameterDecoratorHandlerOptions();
        this.#customNativeParameterDecoratorHandlerOptions =
            this.#buildCustomNativeParameterDecoratorHandlerOptions();
        this.httpAdapterOptions = this.#parseHttpAdapterOptions(defaultHttpAdapterOptions, httpAdapterOptions);
        this.#globalGuardList = [];
        this.#globalInterceptorList = [];
        this.#globalPipeList = [];
        this.#errorTypeToGlobalErrorFilterMap = new Map();
        this._logger = this.#buildLogger(this.httpAdapterOptions);
        this.#isBuilt = false;
        this.#postHandlerMiddlewareList = [];
        this.#preHandlerMiddlewareList = [];
        this.#setErrorHttpResponseErrorFilter();
        this._app = this._buildApp(customApp);
    }
    applyGlobalMiddleware(...middlewareList) {
        if (this.#isBuilt) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'Cannot apply global middleware after the server has been built');
        }
        const middlewareOptions = (0, framework_core_1.buildMiddlewareOptionsFromApplyMiddlewareOptions)(middlewareList);
        this.#postHandlerMiddlewareList.push(...middlewareOptions.postHandlerMiddlewareList);
        this.#preHandlerMiddlewareList.push(...middlewareOptions.preHandlerMiddlewareList);
    }
    applyGlobalGuards(...guardList) {
        if (this.#isBuilt) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'Cannot apply global guards after the server has been built');
        }
        this.#globalGuardList.push(...guardList);
    }
    async build() {
        if (this.#isBuilt) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'The server has already been built');
        }
        this.#bindAdapterRelatedServices();
        await this.#registerControllers();
        this.#isBuilt = true;
        return this._app;
    }
    useGlobalFilters(...errorFilterList) {
        for (const errorFilter of errorFilterList) {
            this.#setGlobalErrorFilter(errorFilter);
        }
    }
    useGlobalInterceptors(...interceptorList) {
        if (this.#isBuilt) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'Cannot apply global interceptors after the server has been built');
        }
        for (const interceptor of interceptorList) {
            this.#globalInterceptorList.push(interceptor);
        }
    }
    useGlobalPipe(...pipeList) {
        if (this.#isBuilt) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'Cannot apply global pipes after the server has been built');
        }
        this.#globalPipeList.push(...pipeList);
    }
    async #appendHandlerParam(params, index, param, type) {
        params[index] = this.#awaitableRequestMethodParamTypes.has(type)
            ? await param
            : param;
    }
    #appendHeaderMetadata(headerMetadata, headers) {
        if (headerMetadata === undefined) {
            return headers;
        }
        if (headers === undefined) {
            return { ...headerMetadata };
        }
        for (const key in headerMetadata) {
            if (!Object.hasOwn(headers, key)) {
                headers[key] = headerMetadata[key];
            }
        }
        return headers;
    }
    #bindAdapterRelatedServices() {
        if (this.#container.isBound(httpApplicationServiceIdentifier_1.httpApplicationServiceIdentifier)) {
            throw new InversifyHttpAdapterError_1.InversifyHttpAdapterError(InversifyHttpAdapterErrorKind_1.InversifyHttpAdapterErrorKind.invalidOperationAfterBuild, 'An HTTP server is already registered in the container');
        }
        this.#container
            .bind(httpApplicationServiceIdentifier_1.httpApplicationServiceIdentifier)
            .toConstantValue(this._app);
    }
    #buildCustomParameterDecoratorHandlerOptions() {
        return {
            getBody: this._getBody.bind(this),
            getCookies: this._getCookies.bind(this),
            getHeaders: this._getHeaders.bind(this),
            getParams: this._getParams.bind(this),
            getQuery: this._getQuery.bind(this),
            setHeader: this._setHeader.bind(this),
            setStatus: this._setStatus.bind(this),
        };
    }
    #buildCustomNativeParameterDecoratorHandlerOptions() {
        return {
            getBody: this._getBody.bind(this),
            getCookies: this._getCookies.bind(this),
            getHeaders: this._getHeaders.bind(this),
            getParams: this._getParams.bind(this),
            getQuery: this._getQuery.bind(this),
            send: this.#reply.bind(this),
            sendBodySeparator: this._sendBodySeparator.bind(this),
            setHeader: this._setHeader.bind(this),
            setStatus: this._setStatus.bind(this),
        };
    }
    #buildLogger(httpAdapterOptions) {
        if (typeof httpAdapterOptions.logger === 'boolean') {
            return new logger_1.ConsoleLogger();
        }
        return httpAdapterOptions.logger;
    }
    #builRouteParamdHandlerList(routerExplorerControllerMetadata) {
        return routerExplorerControllerMetadata.controllerMethodMetadataList.map((routerExplorerControllerMethodMetadata) => ({
            guardList: [
                ...this.#getGuardHandlerFromMetadata(this.#globalGuardList, routerExplorerControllerMethodMetadata),
                ...this.#getGuardHandlerFromMetadata(routerExplorerControllerMethodMetadata.guardList, routerExplorerControllerMethodMetadata),
            ],
            handler: this.#buildHandler(routerExplorerControllerMetadata.serviceIdentifier, routerExplorerControllerMetadata.target, routerExplorerControllerMethodMetadata),
            path: routerExplorerControllerMethodMetadata.path,
            postHandlerMiddlewareList: [
                ...this.#getMiddlewareHandlerFromMetadata(routerExplorerControllerMethodMetadata, this.#postHandlerMiddlewareList),
                ...this.#getMiddlewareHandlerFromMetadata(routerExplorerControllerMethodMetadata, routerExplorerControllerMethodMetadata.postHandlerMiddlewareList),
            ],
            preHandlerMiddlewareList: [
                ...this.#getMiddlewareHandlerFromMetadata(routerExplorerControllerMethodMetadata, this.#preHandlerMiddlewareList),
                ...this.#getMiddlewareHandlerFromMetadata(routerExplorerControllerMethodMetadata, routerExplorerControllerMethodMetadata.preHandlerMiddlewareList),
            ],
            requestMethodType: routerExplorerControllerMethodMetadata.requestMethodType,
        }));
    }
    #buildHandler(serviceIdentifier, targetClass, routerExplorerControllerMethodMetadata) {
        const buildCallRouteHandler = this.#buildCallRouteHandler(targetClass, routerExplorerControllerMethodMetadata.methodKey, routerExplorerControllerMethodMetadata.parameterMetadataList, serviceIdentifier);
        let reply;
        if (routerExplorerControllerMethodMetadata.useNativeHandler) {
            reply = (req, res, value) => {
                if (routerExplorerControllerMethodMetadata.statusCode !== undefined) {
                    this._setStatus(req, res, routerExplorerControllerMethodMetadata.statusCode);
                }
                this.#setHeaders(req, res, routerExplorerControllerMethodMetadata.headerMetadataList);
                return value;
            };
        }
        else {
            reply = (req, res, value) => this.#reply(req, res, value, routerExplorerControllerMethodMetadata.statusCode, routerExplorerControllerMethodMetadata.headerMetadataList);
        }
        const handleError = this.#buildHandleError(routerExplorerControllerMethodMetadata);
        return (0, buildInterceptedHandler_1.buildInterceptedHandler)([
            ...routerExplorerControllerMethodMetadata.interceptorList,
            ...this.#globalInterceptorList,
        ], this.#container, buildCallRouteHandler, handleError, reply);
    }
    #buildCallRouteHandler(targetClass, controllerMethodKey, controllerMethodParameterMetadataList, serviceIdentifier) {
        if (controllerMethodParameterMetadataList.length === 0) {
            return async () => {
                const controller = await this.#container.getAsync(serviceIdentifier);
                return controller[controllerMethodKey]();
            };
        }
        const provideSyncBuilder = (0, areAllParamsSync_1.areAllParamsSync)(this.#awaitableRequestMethodParamTypes, controllerMethodParameterMetadataList, this.#globalPipeList);
        const paramBuilders = controllerMethodParameterMetadataList.map((controllerMethodParameterMetadata) => {
            if (controllerMethodParameterMetadata === undefined) {
                return undefined;
            }
            switch (controllerMethodParameterMetadata.parameterType) {
                case RequestMethodParameterType_1.RequestMethodParameterType.Body:
                    return (request, response) => this._getBody(request, response, controllerMethodParameterMetadata.parameterName);
                case RequestMethodParameterType_1.RequestMethodParameterType.Cookies:
                    return (request, response) => this._getCookies(request, response, controllerMethodParameterMetadata.parameterName);
                case RequestMethodParameterType_1.RequestMethodParameterType.Custom:
                    return (request, response) => controllerMethodParameterMetadata.customParameterDecoratorHandler(request, response, this.#customParameterDecoratorHandlerOptions);
                case RequestMethodParameterType_1.RequestMethodParameterType.CustomNative:
                    return (request, response) => controllerMethodParameterMetadata.customParameterDecoratorHandler(request, response, this.#customNativeParameterDecoratorHandlerOptions);
                case RequestMethodParameterType_1.RequestMethodParameterType.Headers:
                    return (request) => this._getHeaders(request, controllerMethodParameterMetadata.parameterName);
                case RequestMethodParameterType_1.RequestMethodParameterType.Next:
                    return (_request, _response, next) => next;
                case RequestMethodParameterType_1.RequestMethodParameterType.Params:
                    return (request) => this._getParams(request, controllerMethodParameterMetadata.parameterName);
                case RequestMethodParameterType_1.RequestMethodParameterType.Query:
                    return (request) => this._getQuery(request, controllerMethodParameterMetadata.parameterName);
                case RequestMethodParameterType_1.RequestMethodParameterType.Request:
                    return (request) => request;
                case RequestMethodParameterType_1.RequestMethodParameterType.Response:
                    return (_request, response) => response;
            }
        });
        if (provideSyncBuilder) {
            return (0, buildSyncCallRouteHandler_1.buildSyncCallRouteHandler)(this.#container, serviceIdentifier, controllerMethodKey, paramBuilders);
        }
        return async (request, response, next) => {
            const params = new Array(controllerMethodParameterMetadataList.length);
            await Promise.all(paramBuilders.map(async (paramBuilder, index) => {
                const controllerMethodParameterMetadata = controllerMethodParameterMetadataList[index];
                await this.#appendHandlerParam(params, index, paramBuilder(request, response, next), controllerMethodParameterMetadata.parameterType);
                await this.#applyPipeList(params, [
                    ...this.#globalPipeList,
                    ...controllerMethodParameterMetadata.pipeList,
                ], {
                    methodName: controllerMethodKey,
                    parameterIndex: index,
                    targetClass,
                });
            }));
            const controller = await this.#container.getAsync(serviceIdentifier);
            return controller[controllerMethodKey](...params);
        };
    }
    async #applyPipeList(params, pipeList, pipeMetadata) {
        for (const pipeOrServiceIdentifier of pipeList) {
            const pipe = (0, framework_core_1.isPipe)(pipeOrServiceIdentifier)
                ? pipeOrServiceIdentifier
                : await this.#container.getAsync(pipeOrServiceIdentifier);
            params[pipeMetadata.parameterIndex] = await pipe.execute(params[pipeMetadata.parameterIndex], pipeMetadata);
        }
    }
    async #getErrorFilterForError(error, errorToFilterMapList) {
        return (0, getErrorFilterForError_1.getErrorFilterForError)(this.#container, error, errorToFilterMapList);
    }
    #buildHandleError(routerExplorerControllerMethodMetadata) {
        const handleError = async (request, response, error) => {
            const errorFilter = await this.#getErrorFilterForError(error, [
                routerExplorerControllerMethodMetadata.errorTypeToErrorFilterMap,
                this.#errorTypeToGlobalErrorFilterMap,
            ]);
            if (errorFilter === undefined) {
                let httpResponse = undefined;
                this.#printError(error);
                httpResponse = new InternalServerErrorHttpResponse_1.InternalServerErrorHttpResponse(undefined, undefined, {
                    cause: error,
                });
                return this.#reply(request, response, httpResponse, undefined, routerExplorerControllerMethodMetadata.headerMetadataList);
            }
            try {
                return await errorFilter.catch(error, request, response);
            }
            catch (error) {
                return handleError(request, response, error);
            }
        };
        return handleError;
    }
    #parseHttpAdapterOptions(defaultHttpAdapterOptions, httpAdapterOptions) {
        return {
            ...defaultHttpAdapterOptions,
            ...httpAdapterOptions,
        };
    }
    #reply(request, response, value, statusCode, headerMetadata) {
        let httpStatusCode = statusCode;
        let headers = undefined;
        let body = undefined;
        if ((0, isHttpResponse_1.isHttpResponse)(value)) {
            httpStatusCode = value.statusCode;
            headers = value.headers;
            body = value.body;
        }
        else {
            body = value;
        }
        if (httpStatusCode !== undefined) {
            this._setStatus(request, response, httpStatusCode);
        }
        headers = this.#appendHeaderMetadata(headerMetadata, headers);
        if (headers !== undefined) {
            this.#setHeaders(request, response, headers);
        }
        if (typeof body === 'string') {
            return this._replyText(request, response, body);
        }
        else if (body === undefined || typeof body === 'object') {
            if (body instanceof node_stream_1.Readable) {
                return this._replyStream(request, response, body);
            }
            else {
                return this._replyJson(request, response, body);
            }
        }
        else {
            return this._replyText(request, response, JSON.stringify(body));
        }
    }
    #setHeaders(request, response, headers) {
        for (const key in headers) {
            this._setHeader(request, response, key, headers[key]);
        }
    }
    #getMiddlewareHandlerFromMetadata(routerExplorerControllerMethodMetadata, middlewareServiceIdentifierList) {
        const handleError = this.#buildHandleError(routerExplorerControllerMethodMetadata);
        return middlewareServiceIdentifierList.map((middlewareServiceIdentifier) => {
            return async (request, response, next) => {
                try {
                    const middleware = await this.#container.getAsync(middlewareServiceIdentifier);
                    return await middleware.execute(request, response, next);
                }
                catch (error) {
                    return handleError(request, response, error);
                }
            };
        });
    }
    #getGuardHandlerFromMetadata(guardServiceIdentifierList, routerExplorerControllerMethodMetadata) {
        const handleError = this.#buildHandleError(routerExplorerControllerMethodMetadata);
        return guardServiceIdentifierList.map((guardServiceIdentifier) => {
            return async (request, response, next) => {
                try {
                    const guard = await this.#container.getAsync(guardServiceIdentifier);
                    const isAllowed = await guard.activate(request);
                    if (isAllowed) {
                        await next();
                        return undefined;
                    }
                    return await this.#reply(request, response, new ForbiddenHttpResponse_1.ForbiddenHttpResponse(), undefined, routerExplorerControllerMethodMetadata.headerMetadataList);
                }
                catch (error) {
                    return handleError(request, response, error);
                }
            };
        });
    }
    #printController(controllerName, path, routerExplorerControllerMethodMetadataList) {
        if (this.httpAdapterOptions.logger !== false) {
            this._logger.info(`${controllerName} {${path}}:`);
            for (const controllerMethodMetadata of routerExplorerControllerMethodMetadataList) {
                this._logger.info(`  - .${controllerMethodMetadata.methodKey}() mapped {${controllerMethodMetadata.path}, ${controllerMethodMetadata.requestMethodType}}`);
            }
        }
    }
    #printError(error) {
        const errorMessage = DEFAULT_ERROR_MESSAGE;
        if (error instanceof Error) {
            this._logger.error(error.stack ?? error.message);
        }
        this._logger.error(errorMessage);
    }
    async #registerControllers() {
        const routerExplorerControllerMetadataList = (0, buildRouterExplorerControllerMetadataList_1.buildRouterExplorerControllerMetadataList)(this.#container, this._logger);
        for (const routerExplorerControllerMetadata of routerExplorerControllerMetadataList) {
            await this._buildRouter({
                path: routerExplorerControllerMetadata.path,
                routeParamsList: this.#builRouteParamdHandlerList(routerExplorerControllerMetadata),
            });
            this.#printController(routerExplorerControllerMetadata.target.name, routerExplorerControllerMetadata.path, routerExplorerControllerMetadata.controllerMethodMetadataList);
        }
    }
    #setGlobalErrorFilter(errorFilter) {
        (0, setErrorFilterToErrorFilterMap_1.setErrorFilterToErrorFilterMap)(this._logger, this.#errorTypeToGlobalErrorFilterMap, errorFilter);
    }
    #setErrorHttpResponseErrorFilter() {
        this.#errorTypeToGlobalErrorFilterMap.set(ErrorHttpResponse_1.ErrorHttpResponse, (0, buildHttpResponseErrorFilter_1.buildHttpResponseErrorFilter)(this.#reply.bind(this)));
    }
}
exports.InversifyHttpAdapter = InversifyHttpAdapter;
//# sourceMappingURL=InversifyHttpAdapter.js.map