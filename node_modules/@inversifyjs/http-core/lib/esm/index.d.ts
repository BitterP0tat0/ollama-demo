import { Middleware, ApplyMiddlewareOptions, Guard, ErrorFilter, Interceptor, Pipe } from '@inversifyjs/framework-core';
export { ApplyMiddleware, CatchError, CatchErrorOptions, ErrorFilter, Guard, Interceptor, InterceptorTransformObject, Middleware, MiddlewarePhase, Pipe, PipeMetadata, UseErrorFilter, UseGuard, UseInterceptor } from '@inversifyjs/framework-core';
import { Readable, Stream } from 'node:stream';
import { Logger } from '@inversifyjs/logger';
import { Container, ServiceIdentifier, Newable, BindingScope } from 'inversify';

interface HttpAdapterOptions {
    logger?: boolean | Logger;
}

declare enum HttpStatusCode {
    CONTINUE = 100,
    SWITCHING_PROTOCOLS = 101,
    PROCESSING = 102,
    EARLYHINTS = 103,
    OK = 200,
    CREATED = 201,
    ACCEPTED = 202,
    NON_AUTHORITATIVE_INFORMATION = 203,
    NO_CONTENT = 204,
    RESET_CONTENT = 205,
    PARTIAL_CONTENT = 206,
    MULTI_STATUS = 207,
    ALREADY_REPORTED = 208,
    CONTENT_DIFFERENT = 210,
    AMBIGUOUS = 300,
    MOVED_PERMANENTLY = 301,
    FOUND = 302,
    SEE_OTHER = 303,
    NOT_MODIFIED = 304,
    TEMPORARY_REDIRECT = 307,
    PERMANENT_REDIRECT = 308,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    PAYMENT_REQUIRED = 402,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    METHOD_NOT_ALLOWED = 405,
    NOT_ACCEPTABLE = 406,
    PROXY_AUTHENTICATION_REQUIRED = 407,
    REQUEST_TIMEOUT = 408,
    CONFLICT = 409,
    GONE = 410,
    LENGTH_REQUIRED = 411,
    PRECONDITION_FAILED = 412,
    PAYLOAD_TOO_LARGE = 413,
    URI_TOO_LONG = 414,
    UNSUPPORTED_MEDIA_TYPE = 415,
    REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    EXPECTATION_FAILED = 417,
    I_AM_A_TEAPOT = 418,
    MISDIRECTED = 421,
    UNPROCESSABLE_ENTITY = 422,
    LOCKED = 423,
    FAILED_DEPENDENCY = 424,
    PRECONDITION_REQUIRED = 428,
    TOO_MANY_REQUESTS = 429,
    UNRECOVERABLE_ERROR = 456,
    INTERNAL_SERVER_ERROR = 500,
    NOT_IMPLEMENTED = 501,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
    GATEWAY_TIMEOUT = 504,
    HTTP_VERSION_NOT_SUPPORTED = 505,
    INSUFFICIENT_STORAGE = 507,
    LOOP_DETECTED = 508
}

declare enum RequestMethodParameterType {
    Body = "body",
    Cookies = "cookies",
    Custom = "custom",
    CustomNative = "customNative",
    Headers = "headers",
    Next = "next",
    Params = "params",
    Request = "request",
    Response = "response",
    Query = "query"
}

type RequiredOptions<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};

type MiddlewareHandler<TRequest, TResponse, TNextFunction, TResult = unknown> = (req: TRequest, res: TResponse, next: TNextFunction) => Promise<TResult> | TResult;

type RequestHandler<TRequest, TResponse, TNextFunction, TResult = unknown> = (req: TRequest, res: TResponse, next: TNextFunction) => Promise<TResult> | TResult;

declare enum RequestMethodType {
    All = "all",
    Delete = "delete",
    Get = "get",
    Head = "head",
    Options = "options",
    Patch = "patch",
    Post = "post",
    Put = "put"
}

interface RouteParams<TRequest, TResponse, TNextFunction, TResult> {
    guardList: MiddlewareHandler<TRequest, TResponse, TNextFunction, TResult | undefined>[];
    handler: RequestHandler<TRequest, TResponse, TNextFunction, TResult>;
    path: string;
    postHandlerMiddlewareList: MiddlewareHandler<TRequest, TResponse, TNextFunction, TResult>[];
    preHandlerMiddlewareList: MiddlewareHandler<TRequest, TResponse, TNextFunction, TResult>[];
    requestMethodType: RequestMethodType;
}

interface RouterParams<TRequest, TResponse, TNextFunction, TResult> {
    path: string;
    routeParamsList: RouteParams<TRequest, TResponse, TNextFunction, TResult>[];
}

declare abstract class InversifyHttpAdapter<TRequest, TResponse, TNextFunction extends (err?: any) => Promise<void> | void, TResult, TOptions extends HttpAdapterOptions = HttpAdapterOptions, TApp = unknown, TParams extends Record<string | number, unknown> = Record<string, string>> {
    #private;
    protected readonly httpAdapterOptions: RequiredOptions<TOptions>;
    protected readonly _app: TApp;
    protected readonly _logger: Logger;
    abstract readonly id: string | symbol;
    constructor(container: Container, defaultHttpAdapterOptions: RequiredOptions<TOptions>, httpAdapterOptions: TOptions | undefined, awaitableRequestMethodParamTypes?: Iterable<RequestMethodParameterType> | undefined, customApp?: TApp);
    applyGlobalMiddleware(...middlewareList: (ServiceIdentifier<Middleware> | ApplyMiddlewareOptions)[]): void;
    applyGlobalGuards(...guardList: ServiceIdentifier<Guard<TRequest>>[]): void;
    build(): Promise<TApp>;
    useGlobalFilters(...errorFilterList: Newable<ErrorFilter>[]): void;
    useGlobalInterceptors(...interceptorList: ServiceIdentifier<Interceptor<TRequest, TResponse>>[]): void;
    useGlobalPipe(...pipeList: (ServiceIdentifier<Pipe> | Pipe)[]): void;
    protected abstract _buildApp(customApp: TApp | undefined): TApp;
    protected abstract _getBody(request: TRequest, response: TResponse, parameterName?: string): unknown;
    protected abstract _getParams(request: TRequest): TParams;
    protected abstract _getParams(request: TRequest, parameterName: string): TParams[string] | undefined;
    protected abstract _getParams(request: TRequest, parameterName?: string): TParams | TParams[string] | undefined;
    protected abstract _getQuery(request: TRequest): Record<string, unknown>;
    protected abstract _getQuery(request: TRequest, parameterName: string): unknown;
    protected abstract _getQuery(request: TRequest, parameterName?: string): unknown;
    protected abstract _getHeaders(request: TRequest): Record<string, string | string[] | undefined>;
    protected abstract _getHeaders(request: TRequest, parameterName: string): string | string[] | undefined;
    protected abstract _getHeaders(request: TRequest, parameterName?: string): Record<string, string | string[] | undefined> | string | string[] | undefined;
    protected abstract _getCookies(request: TRequest, response: TResponse, parameterName?: string): unknown;
    protected abstract _replyText(request: TRequest, response: TResponse, value: string): TResult;
    protected abstract _replyJson(request: TRequest, response: TResponse, value?: object): TResult;
    protected abstract _replyStream(request: TRequest, response: TResponse, value: Readable): TResult | Promise<TResult>;
    protected abstract _sendBodySeparator(request: TRequest, response: TResponse): void | Promise<void>;
    protected abstract _setStatus(request: TRequest, response: TResponse, statusCode: HttpStatusCode): void;
    protected abstract _setHeader(request: TRequest, response: TResponse, key: string, value: string): void;
    protected abstract _buildRouter(routerParams: RouterParams<TRequest, TResponse, TNextFunction, TResult>): void | Promise<void>;
}

declare function buildNormalizedPath(path: string): string;

declare const isHttpResponse$1: unique symbol;
interface HttpResponse {
    [isHttpResponse$1]: true;
    body?: object | string | number | boolean | Stream | undefined;
    headers?: Record<string, string> | undefined;
    statusCode: HttpStatusCode;
}

type ControllerResponse = HttpResponse | object | string | number | boolean | Readable | undefined;

interface CustomParameterDecoratorHandlerOptions<TRequest, TResponse> {
    getBody: (request: TRequest, response: TResponse, parameterName?: string) => unknown;
    getCookies: (request: TRequest, response: TResponse, parameterName?: string) => unknown;
    getHeaders: (request: TRequest, parameterName?: string) => unknown;
    getParams: (request: TRequest, parameterName?: string) => unknown;
    getQuery: (request: TRequest, parameterName?: string) => unknown;
    setHeader(request: TRequest, response: TResponse, key: string, value: string): void;
    setStatus(request: TRequest, response: TResponse, statusCode: HttpStatusCode): void;
}

interface CustomNativeParameterDecoratorHandlerOptions<TRequest = any, TResponse = any, TResult = any> extends CustomParameterDecoratorHandlerOptions<TRequest, TResponse> {
    send(request: TRequest, response: TResponse, value: ControllerResponse): TResult | Promise<TResult>;
    sendBodySeparator(request: TRequest, response: TResponse): void | Promise<void>;
}

type CustomNativeParameterDecoratorHandler<TRequest = any, TResponse = any, TDecoratorResult = any, TResult = any> = (request: TRequest, response: TResponse, options: CustomNativeParameterDecoratorHandlerOptions<TRequest, TResponse, TResult>) => Promise<TDecoratorResult> | TDecoratorResult;

declare function createCustomNativeParameterDecorator<TRequest, TResponse, TDecoratorResult, TResult>(handler: CustomNativeParameterDecoratorHandler<TRequest, TResponse, TDecoratorResult, TResult>, ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

type CustomParameterDecoratorHandler<TRequest = any, TResponse = any, TResult = any> = (request: TRequest, response: TResponse, options: CustomParameterDecoratorHandlerOptions<TRequest, TResponse>) => Promise<TResult> | TResult;

declare function createCustomParameterDecorator<TRequest, TResponse, TResult>(handler: CustomParameterDecoratorHandler<TRequest, TResponse, TResult>, ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare const All: (path?: string) => MethodDecorator;

interface RouteParamOptions {
    name?: string | undefined;
}

declare function Body(optionsOrPipe?: RouteParamOptions | (ServiceIdentifier<Pipe> | Pipe), ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

interface ControllerOptions {
    path?: string;
    priority?: number;
    scope?: BindingScope;
    serviceIdentifier?: ServiceIdentifier;
}

declare function Controller(pathOrOptions?: string | ControllerOptions): ClassDecorator;

declare function Cookies(optionsOrPipe?: RouteParamOptions | (ServiceIdentifier<Pipe> | Pipe), ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare const Delete: (path?: string) => MethodDecorator;

declare const Get: (path?: string) => MethodDecorator;

declare const Head: (path?: string) => MethodDecorator;

declare function Headers(optionsOrPipe?: RouteParamOptions | (ServiceIdentifier<Pipe> | Pipe), ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare function Next(): ParameterDecorator;

declare const Options: (path?: string) => MethodDecorator;

declare function Params(optionsOrPipe?: RouteParamOptions | (ServiceIdentifier<Pipe> | Pipe), ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare const Patch: (path?: string) => MethodDecorator;

declare const Post: (path?: string) => MethodDecorator;

declare const Put: (path?: string) => MethodDecorator;

declare function Query(optionsOrPipe?: RouteParamOptions | (ServiceIdentifier<Pipe> | Pipe), ...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare function Request(...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare function Response(...parameterPipeList: (ServiceIdentifier<Pipe> | Pipe)[]): ParameterDecorator;

declare function SetHeader(headerKey: string, value: string): MethodDecorator;

declare function StatusCode(statusCode: HttpStatusCode): MethodDecorator;

declare const httpApplicationServiceIdentifier: unique symbol;

declare function isHttpResponse(value: unknown): value is HttpResponse;

declare class SuccessHttpResponse implements HttpResponse {
    readonly statusCode: HttpStatusCode;
    readonly body?: (object | string | number | boolean | Stream) | undefined;
    readonly headers?: Record<string, string> | undefined;
    [isHttpResponse$1]: true;
    constructor(statusCode: HttpStatusCode, body?: (object | string | number | boolean | Stream) | undefined, headers?: Record<string, string> | undefined);
}

declare class AcceptedHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class AlreadyReportedHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class ErrorHttpResponse extends Error implements HttpResponse {
    readonly statusCode: HttpStatusCode;
    readonly body?: object | string | number | boolean | Stream | undefined;
    readonly headers?: Record<string, string> | undefined;
    readonly [isHttpResponse$1]: true;
    constructor(statusCode: HttpStatusCode, body?: object | string | number | boolean | Stream | undefined, message?: string | undefined, errorOptions?: ErrorOptions | undefined, headers?: Record<string, string> | undefined);
}

declare class BadGatewayHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class BadRequestHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class ConflictHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class ContentDifferentHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class CreatedHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class ForbiddenHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class GatewayTimeoutHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class GoneHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class HttpVersionNotSupportedHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class InsufficientStorageHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class InternalServerErrorHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class LoopDetectedHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class MethodNotAllowedHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class MultiStatusHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class NoContentHttpResponse extends SuccessHttpResponse {
    constructor(headers?: Record<string, string>);
}

declare class NonAuthoritativeInformationHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class NotAcceptableHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class NotFoundHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class NotImplementedHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class OkHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class PartialContentHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class PaymentRequiredHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class ResetContentHttpResponse extends SuccessHttpResponse {
    constructor(body?: object | string | number | boolean, headers?: Record<string, string>);
}

declare class ServiceUnavailableHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class UnauthorizedHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare class UnprocessableEntityHttpResponse extends ErrorHttpResponse {
    constructor(body?: object | string | number | boolean | Stream | undefined, errorMessage?: string, errorOptions?: ErrorOptions, headers?: Record<string, string>);
}

declare function handleMiddlewareList<TRequest, TResponse, TResult>(orderedHandlers: MiddlewareHandler<TRequest, TResponse, () => void, TResult>[]): (request: TRequest, response: TResponse) => Promise<TResult>;

interface ControllerMetadata {
    path: string;
    priority: number;
    serviceIdentifier: ServiceIdentifier;
    target: NewableFunction;
}

declare function getControllerMetadataList(): ControllerMetadata[] | undefined;

interface ControllerMethodMetadata {
    path: string;
    requestMethodType: RequestMethodType;
    methodKey: string | symbol;
}

declare function getControllerMethodMetadataList(controllerConstructor: NewableFunction): ControllerMethodMetadata[];

export { AcceptedHttpResponse, All, AlreadyReportedHttpResponse, BadGatewayHttpResponse, BadRequestHttpResponse, Body, ConflictHttpResponse, ContentDifferentHttpResponse, Controller, Cookies, CreatedHttpResponse, Delete, ErrorHttpResponse, ForbiddenHttpResponse, GatewayTimeoutHttpResponse, Get, GoneHttpResponse, Head, Headers, HttpStatusCode, HttpVersionNotSupportedHttpResponse, InsufficientStorageHttpResponse, InternalServerErrorHttpResponse, InversifyHttpAdapter, LoopDetectedHttpResponse, MethodNotAllowedHttpResponse, MultiStatusHttpResponse, Next, NoContentHttpResponse, NonAuthoritativeInformationHttpResponse, NotAcceptableHttpResponse, NotFoundHttpResponse, NotImplementedHttpResponse, OkHttpResponse, Options, Params, PartialContentHttpResponse, Patch, PaymentRequiredHttpResponse, Post, Put, Query, Request, RequestMethodParameterType, RequestMethodType, ResetContentHttpResponse, Response, ServiceUnavailableHttpResponse, SetHeader, StatusCode, SuccessHttpResponse, UnauthorizedHttpResponse, UnprocessableEntityHttpResponse, buildNormalizedPath, createCustomNativeParameterDecorator, createCustomParameterDecorator, getControllerMetadataList, getControllerMethodMetadataList, handleMiddlewareList, httpApplicationServiceIdentifier, isHttpResponse, isHttpResponse$1 as isHttpResponseSymbol };
export type { ControllerMetadata, ControllerMethodMetadata, ControllerOptions, ControllerResponse, CustomNativeParameterDecoratorHandler, CustomNativeParameterDecoratorHandlerOptions, CustomParameterDecoratorHandler, CustomParameterDecoratorHandlerOptions, HttpAdapterOptions, HttpResponse, MiddlewareHandler, RequestHandler, RequiredOptions, RouteParamOptions, RouteParams, RouterParams };
